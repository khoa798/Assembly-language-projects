; Khoa Hoang
; klhoang
; Lab 4: Caesar Cipher


	.ORIG x3000
	; Strings
	HELLO .STRINGZ "Welcome to my Caesar Cipher!\n"
	CIPH .STRINGZ "\nWhat is your cipher(1-25)?\n"
	WHATST .STRINGZ "What is the string(up to 200 characters)?\n"
	DESIRE .STRINGZ "Would you to like (E)ncrypt, (D)ecrypt, or e(X)it?\n"
	NL .STRINGZ "\n"
	TERM	.STRINGZ "\nGOODBYE!\n"
	HERE	.STRINGZ "\n Here is your string and the decrypted result\n"
	LEA R0, HELLO
	PUTS
RESET	AND R1, R1, 0	; storing INT here
	AND R2, R2, 0	; storing COUNT
	AND R3, R3, 0	; ASCII value of INT offset
	AND R4, R4, 0	; ASCII offset of hyphen
	AND R5, R5, 0	; trash register
	AND R6, R6, 0	; indication for flag
	AND R7, R7, 0	;

	LEA R0, DESIRE
	PUTS

	GETC		; WAIT FOR INPUT
	OUT
	LD R5, EXIT	; CHECK IF USER WOULD LIKE TO QUIT
	ADD R1, R0, R5 	; ADD THE INVERSE ASCII VALUE OF X TO INPUT
	BRz QUIT	; JUMP TO QUIT IF USER ENTERED IN X
	;
	LD R5, E	; CHECK IF USER WANTS TO ENCRYPT
	ADD R1, R0, R5	; ADD INVERSE ASCII VALUE OF 'E' FOR ENCRYPTION
	BRz CIPHER	; JUMP TO ASK USER FOR CIPHER VALUE
	;
	LD R5, D	; CHECK IF USER WANTS TO DECRYPT 
	ADD R1, R0, R5	; ADD INVERSE ASCII VALUE OF 'D' FOR DECRYPTION
	BRnp RESET	; IF NONE OF THE ABOVE, ASK AGAIN.
FlagC	ADD R6, R6,#1	; CHECKS IF USER WANTS TO DECRYPT(1) OR ENCRYPT(0)
	ST R6, FLAG	; FLAG REGISTER = 1 OR 0
	AND R6,R6,0
	;
CIPHER 
	LEA R0, CIPH	; ASK THE USER FOR WHICH VALUE THEY WANT FOR CIPHER
	PUTS		; PRINT OUT STRING
NUM	GETC		; WAIT FOR INPUT, LOOPS THROUGH IF VALUE > 9
	OUT
	
	LD R5, ENTER	; INVERSE ASCII OF NEWLINE, CHECK IF USER PRESSES ENTER
	ADD R1, R0, R5	; CHECK IF USER PRESSED ENTER
	BRz DCPT	; IF DID, JUMP TO DECRYPT
	
	LD R5, NUMNINE	; ELSE CHECK IF VALUE WAS <9
	ADD R1, R0, R5	
	BRp RESET	; JUMP BACK TO START IF LESS THAN 9
	
	LD R5, NUMZERO	; CHECKS IF VALUE IS GREATER OR EQUAL TO 0
	ADD R1, R0, R5	; CHECKING....
	BRn RESET	; IF NOT GO TO RESTART
	ADD R4, R1,#-1	; STORE VALUE IN R4
	AND R6, R6,#0	; 

TIMES	
	ADD R6, R6,R3	; MULTIPLIES THE NUMBER BY 10
	ADD R2,R2,#-1	; DECREMENT
	BRp TIMES

	ADD R3, R6, R4	; ADD NEXT NUMBER
	ADD R5, R3, #0
	ST R5, INT	; STORES THE VALUE IN R5 TO INT
	AND R2, R2, #0	
	ADD R2, R2, #10
	BRnzp NUM

QUIT	LEA R0, TERM	; IF USER WANTS TO QUIT, GET STRING
	PUTS		; PRINT THE STRING
	HALT		; STOP THE PROGRAM
	
DCPT	LEA R0, WHATST
	PUTS
	
	AND R1, R1, #0 ; CLEARS REGISTERS BELOW
	AND R2, R2, #0
	AND R3, R3, #0	
	AND R4, R4, #0 ; CLEARS REGISTERS BELOW
	AND R5, R5, #0
	AND R6, R6, #0
	LD R4, HUNTWO 	; LOAD FOR 2X200 ARRAY
	
GETAG	GETC		; WAIT FOR INPUT
	OUT		; PRINT INPUT TO TERMINAL
	LD R5, ENTER	; WAIT FOR ENTER
	ADD R2,R0,R5	; INVERSE ASCII OF ENTER WITH USER_INPUT TO CHECK
	BRz ALGO
	
	ADD R5,R0,0	; STORE THE CHARACTER IN R5
	LEA R0, ARRAY	; LOAD UP ARRAY
	ADD R6,R0,R1	; CHANGE THE ARRAY INDEX
	STR R5,R6,0	; STORE THE VALUE IN THE ARRAY
	ADD R1,R1,1
	ADD R4,R4,-1	; DECREMENT FOR LOOP CONTROL
	BRp GETAG	; GO BACK TO GET MORE OF THE STRING, WAITNG FOR ENTER
	


ALGO	LEA R0, ARRAY	; LOAD THE ARRAY
	LD R5, INT	; LOAD UP INT
	AND R1,R1,0
	AND R3, R3,0
	AND R4, R4,0
	AND R6,R6,0
	LD R2, FLAG	; CHECK FLAG DECRYPT(1) OR ENCRYPT(0)
	ADD R2, R2, 0	; CHECK IT..
	BRz ENCRYPT	; IF 0 , GO TO ENCRYPT


DECRYPT 
	JSR jDECRYPT	; CALL DECRYPT SUBROUTINE	
	BRnzp prRESULT	; GO STRAIGHT TO PRINT RESULT AFTER

ENCRYPT 
	JSR jENCRYPT	; CALL ENCRYPT SUBROUTINE


prRESULT
	LEA R0,HERE	; PRINT OUT THE STRING FOR RESULT
	PUTS
	JSR PRINT	; CALL PRINT SUBROUTINE
	LD R0, INT	; LOAD UP INT
	BRnzp RESET	; BEGIN AGAIN

jENCRYPT		; THE ENCRYPT SUBROUTINE
	ADD R2,R0,R3	; LOOP AROUND
	LD R4, HUNTWO
	ADD R1,R2,R4	; DO INDEX + 200
	LDR R6,R2,0	; GET THE CHAR
	BRz DONE
	LD R4, A	; LOAD UP A
	ADD R4,R6,R4	; MAKE THE CHAR > A
	BRn stores	; JUMP TO STORE ENCRYPTION
	LD R4, Z	; LOAD UP Z
	ADD R4,R6,R4	; MAKE THE CHAR > Z
	BRnz TurnCap
	LD R4,a		; LOAD UP a
	ADD R4,R6,R4	; MAKE THE CHAR > a
	BRn stores	; IF NEG STORE IT
	LD R4,z		; LOAD UP z
	ADD R4,R6,R4	; MAKE CHAR<Z
	BRnz TurnLow	; IF NEG, LOWERCASE
	BRp stores	; IF POS, STORE IT
TurnCap
	ADD R6,R6,R5	; ADD THE OFFSET
	LD R4,Z		; LOAD UP Z
	ADD R4,R6,R4	
	BRnz stores
	LD R4,NTWS	; LOAD UP -26
	ADD R6,R6,R4	; OFFSET -26
	BRnzp stores	; STORE AFTER CONVERTED TO CAPITAL

TurnLow
	ADD R6,R6,R5	; ADD THE OFFSET
	LD R4, z 	; LOAD UP z
	ADD R4,R6,R4	; DO OP
	BRnz stores	; STORE THE VALUE
	LD R4, NTWS	; LOAD UP -26
	ADD R6,R6,R4

stores
	STR R6,R1,0	; STORE FUNCTION
	ADD R3,R3,1	; RANDOM REGISTER FOR LOOP CONTROL
	BRnzp jENCRYPT	; JUMP TO ENCRYPTION

DONE	RET		; IF DONE RETURN
	
jDECRYPT
	ADD R2,R0,R3	; LOOP CONTROL
	LD R4, HUNTWO	; LOAD UP 200
	ADD R1,R2,R4	; DO INDEX+200
	LDR R6,R2,0	; LOAD UP ADDRESS
	BRz deDONE	; IF ZERO RETURN DECRYPTED VALUE
	LD R4, A	; LOAD UP A
	ADD R4,R6,R4	; MAKE THE CHAR > A
	BRn deST
	LD R4, Z	; LOAD UP Z
	ADD R4,R6,R4	; MAKE THE CHAR < Z
	BRnz TurnDCapi	; GO TO CONVERT TO CAPITAL SUBROUTINE/FUNCTION
	LD R4, a	; LOAD UP a
	ADD R4,R6,R4	; MAKE THE CHAR > a
	BRn deST	; IF NEG GO TO STORE
	LD R4, z	; LOAD UP z
	ADD R4,R6,R4	; MAKE CHAR < z
	BRnz TurnDLow	; GO TO CONVERT TO LOWERCASE SUBROUTINE
	BRp deST

TurnDCapi
	NOT R4,R5	; INVERSE REGISTER 5 AND STORE TO 4
	ADD R4,R4,1	; INCREMENT
	ADD R6,R6,R4	; ADD CIPHER OFFSET
	LD R4, A
	ADD R4,R6,R4	; CHECK FOR OUT OF BOUNDS
	LD R4,TWS	; LOAD UP 26
	ADD R6,R6,R4	; CORRECTION HERE
	BRnzp deST

TurnDLow
	NOT R4, R5	; INVERSE LIKE ABOVE
	ADD R4,R4,1
	ADD R6,R6,R4
	LD R4, a	; LOAD UP a
	ADD R4,R6,R4	; ADD CIPHER OFFSET
	BRzp deST
	LD R4, TWS	; LOAD UP 26
	ADD R6,R6,R4	; CORRECTION HERE
deST
	STR R6,R1,0	; STORE BACK INSIDE ARRAY
	ADD R3,R3,1	; FOR LOOP CONTROL
	BRnzp jDECRYPT
	
deDONE RET		;IF DONE RETURN VALUE

PRINT			; PRINT SUBROUTINE
	LEA R0, ARRAY	; LOAD UP ARRAY
	PUTS
	LEA R0, NL	; PRINT OUT NEWLINE
	PUTS
	LEA R0, ARRAY	; LOAD UP OTHER PART OF ARRAY
	LD R4, HUNTWO	; LOAD UP 200
	ADD R0,R0,R4
	PUTS
	LEA R0,NL	; PRINT OUT NEWLINE
	PUTS
	BRnzp RESET

; VARIABLES TO BE USED
EXIT	.FILL -88 	; INVERSE ASCII VALUE OF X, CHECKS FOR EXIT
NUMZERO	.FILL -47	; INVERSE ASCII VALUE OF '0'
HUNTWO	.FILL #200	; 200
NUMNINE	.FILL -57	; INVERSE ASCII VALUE OF '9'
INT 	.FILL X0000
FLAG	.FILL 0
A	.FILL -65
Z	.FILL -90
E	.FILL -69 	; INVERSE ASCII VALUE OF E, CHECKS ENCRYPTION
a	.FILL -97
z	.FILL -122
TWS	.FILL #26
NTWS	.FILL #-26
D	.FILL -68 	; INVERSE ASCII VALUE OF D, CHECKS DECRYPTION
ENTER	.FILL -10	; INVERSE ASCII VALUE OF NEWLINE
ARRAY 	.BLKW 400 	; GROUPING OF MEMORY LOCATIONS(ARRAY)

	.END










